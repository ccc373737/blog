## bytecode

编译后的字节码可以解析为类似汇编的opcode，每条opcode都执行相关的栈，内存或存储操作，并且每条opcode都有对应的gas。

https://ethereum.org/en/developers/docs/evm/opcodes/

16进制byte和opcode的对应关系在opcodes.go中，如:
```go
onst (
	PUSH1 OpCode = 0x60 + iota
	PUSH2
	PUSH3
	PUSH4
	PUSH5
	PUSH6
	PUSH7
	PUSH8
	PUSH9
	PUSH10
	PUSH11
	PUSH12
	PUSH13
	PUSH14
	PUSH15
	PUSH16
	PUSH17
	PUSH18
	PUSH19
	PUSH20
	PUSH21
	PUSH22
	PUSH23
	PUSH24
	PUSH25
	PUSH26
	PUSH27
	PUSH28
	PUSH29
	PUSH30
	PUSH31
	PUSH32
)
```

指令信息和gas费定义在jump_table.go，如

```go
PUSH1: {
			execute:     opPush1,
			constantGas: GasFastestStep,
			minStack:    minStack(0, 1),
			maxStack:    maxStack(0, 1),
		},
PUSH2: {
			execute:     makePush(2, 2),
			constantGas: GasFastestStep,
			minStack:    minStack(0, 1),
			maxStack:    maxStack(0, 1),
		},
```

几个重要的指令：

内存相关

- `MSTORE(arg0, arg1)`从栈中获取两个参数，表示`MEM[arg0:arg0+32] = arg1`
- `MLOAD(arg0)`从栈中获取一个参数，表示`PUSH32(MEM[arg0:arg0+32])`

存储相关

- `SSTORE(arg0, arg1)`从栈中获取两个参数，表示`eth.getStorageAt(合约地址, arg0) = arg1`
- `SLOAD(arg0)`从栈中获取一个参数，表示`PUSH32(eth.getStorageAt(合约地址, arg0))`

## 示例分析
```go
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

contract Com {
    int temp = 20;

    function getTemp() view external returns (int) {
        return temp;
    }

    function setTemp(int _temp) external {
        temp = _temp; 
    }
}
```

编译后：

```go
{
	"functionDebugData": {},
	"generatedSources": [],
	"linkReferences": {},
	"object": "6080604052601460005534801561001557600080fd5b50610150806100256000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c8063952525601461003b578063f40639ec14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea26469706673582212207ec0d1f5249d78de95727a4825866d1c5b4b8f481a3c2470206ac72d92f4933b64736f6c63430008080033",
	"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x14 PUSH1 0x0 SSTORE CALLVALUE DUP1 ISZERO PUSH2 0x15 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x150 DUP1 PUSH2 0x25 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x36 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x95252560 EQ PUSH2 0x3B JUMPI DUP1 PUSH4 0xF40639EC EQ PUSH2 0x59 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x43 PUSH2 0x75 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x50 SWAP2 SWAP1 PUSH2 0xA1 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x73 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x6E SWAP2 SWAP1 PUSH2 0xED JUMP JUMPDEST PUSH2 0x7E JUMP JUMPDEST STOP JUMPDEST PUSH1 0x0 DUP1 SLOAD SWAP1 POP SWAP1 JUMP JUMPDEST DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x9B DUP2 PUSH2 0x88 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xB6 PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0x92 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xCA DUP2 PUSH2 0x88 JUMP JUMPDEST DUP2 EQ PUSH2 0xD5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP2 CALLDATALOAD SWAP1 POP PUSH2 0xE7 DUP2 PUSH2 0xC1 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x103 JUMPI PUSH2 0x102 PUSH2 0xBC JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0x111 DUP5 DUP3 DUP6 ADD PUSH2 0xD8 JUMP JUMPDEST SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH31 0xC0D1F5249D78DE95727A4825866D1C5B4B8F481A3C2470206AC72D92F4933B PUSH5 0x736F6C6343 STOP ADDMOD ADDMOD STOP CALLER ",
	"sourceMap": "55:189:0:-:0;;;85:2;74:13;;55:189;;;;;;;;;;;;;;;;"
}
object是opcodes的16进制形式，最终存储在链上就以bytecode形式

```

- 合约引导：60806040526

```go
每个合约总是以此开头
PUSH1 0x80 //将0x80放入堆栈
PUSH1 0x40 //将0x40放入堆栈
MSTORE //在0x40内存地址中写入值0x80
//这是因为地址0-0x7F为内部指令使用地址，外部可使用的内存地址从0x80开始，值0x80
//相当于维护的可用的内存地址的指针，solidity程序总是在内存0x80指针开始初始化。
```

```go
CALLVALUE //msg.value压入stack 
DUP1 //复制栈顶数据 value | value
ISZERO //0值判断 value == 0 | value
PUSH2 0x15 0x15 | value == 0 | value
JUMPI //跳转指令，判断栈第二个元素是否成立，如果成立跳转到0x10位置，否则继续执行
PUSH1 0x0 
DUP1 0 | 0
REVERT //异常返回，第一个元素为相对位置，第二个元素为长度，revert(0,0+0)，即无返回值
//整段代码意思是如果msg.value != 0，那么抛出异常revert，之所以生成这样的字节码是由于
//合约中没有payable构造函数，无法接受value
JUMPDEST
```

```go
JUMPDEST //之前的JUMPI跳转的位置
POP 
PUSH2 0x150 // | 0x150
DUP1 // 0x150 | 0x150
PUSH2 0x25 //0x25 | 0x150 | 0x150
PUSH1 0x0 // 0 | 0x25 | 0x150 | 0x150
CODECOPY //CODECOPY接受三个参数，即将源code从37-37+336 送到内存地址 0-0+336
//0-37 字节码：6080604052601460005534801561001557600080fd5b50610150806100256000396000f3fe
//37-37+336字节码：608060405234801561001057600080fd5b50600436106100365760003560e01c8063952525601461003b578063f40639ec14610059575b600080fd5b610043610075565b60405161005091906100d9565b60405180910390f35b610073600480360381019061006e919061009d565b61007e565b005b60008054905090565b8060008190555050565b60008135905061009781610103565b92915050565b6000602082840312156100b3576100b26100fe565b5b60006100c184828501610088565b91505092915050565b6100d3816100f4565b82525050565b60006020820190506100ee60008301846100ca565b92915050565b6000819050919050565b600080fd5b61010c816100f4565b811461011757600080fd5b5056fea26469706673582212206e8a63df8a16b51e6820770062944d1c2f9a7764de9a3c67f1664e901743503a64736f6c63430008070033
//对应到opcode INVALID之前全部为构建合约引导代码，之后全部为合约本身代码
//这里就将合约本身代码写入到了内存中，随后这部分code会真正写入账户中的code字段
//使用eth.getCode("address")看到的code就是37-37+336中的字节码
PUSH1 0x0 
RETURN 
INVALID
```

合约创建完成之后，之后的调用就全部可以根据code转化为opcode一步一步执行，并消耗对应的gas。

注：solidity语言可以用Assembly Language直接用opcode操作EVM。

### 方法执行

```go
//与创建类似，依然是在0x40内存地址中写入值0x80，初始化可以内存空间指针
//然后检测msg.value，生成此段字节码原因依然是没有payable方法
PUSH1 0x80 
PUSH1 0x40 
MSTORE 
CALLVALUE 
DUP1 
ISZERO 
PUSH2 0x10 
JUMPI 
PUSH1 0x0 
DUP1 
REVERT 
JUMPDEST 

POP 
PUSH1 0x4 
CALLDATASIZE //读取input长度到栈 input | 0x4
LT // input < 0x4
PUSH2 0x36 //0x36 | input < 0x4
JUMPI //如果input < 0x4跳转到jump1位置，然后revert
//input输入的前4个字节应该是方法的hash signature值，如果input小于4个字节被认为是异常

PUSH1 0x0 
CALLDATALOAD //读取input数据前32字节到栈
PUSH1 0xE0 // 224 | CALLDATA
SHR //移位操作 将CALLDATA右移224位（28字节），即剩下前4个字节，就是方法的hash值
DUP1 // CALLDATA(4) | CALLDATA(4)
PUSH4 0x95252560 //0x95252560就是某个方法的hash 0x95252560 | CALLDATA(4) | CALLDATA(4)
EQ //比较操作，这里实际上就是方法选择器，遍历比较多次查找，然后跳转到具体方法相应的位置执行
PUSH2 0x3B 
JUMPI 
DUP1 
PUSH4 0xF40639EC 
EQ //遍历比较查找方法
PUSH2 0x59 J
UMPI 
JUMPDEST //jump1
PUSH1 0x0 //没找对应方法，revert
DUP1 
REVERT
```

注：方法hash计算 web3.keccak(text="getTemp()")[:4]

```go
JUMPDEST 
PUSH2 0x43 
PUSH2 0x75 
JUMP // 0x75 | 0x43 跳转指令，这里跳转到jump2
JUMPDEST //jump3
PUSH1 0x40 //0x40 | 0x14
MLOAD //从内存0x40 - 0x40 + 32读取数据到栈顶，这里最开始内存中放入了0x80
			//0x80 | 0x14
PUSH2 0x50 //0x50 | 0x80 | 0x14
SWAP2 //0x14 | 0x80 | 0x50
SWAP1 //0x80 | 0x14 | 0x50
PUSH2 0xD9 //0xD9 | 0x80 | 0x14 | 0x50
JUMP //跳转到jump4
JUMPDEST //jump9
PUSH1 0x40 //0x40 |  0xa0
MLOAD //从0x40读取32字节 0x80 | 0xa0
DUP1 //0x80 | 0x80 | 0xa0
SWAP2 //0xa0 | 0x80 | 0x80
SUB //0x20 | 0x80
SWAP1 //0x80 | 0x20
RETURN //最终返回 return mem[ost:ost+len] 从内存0x80-0x80 + 0x20返回
JUMPDEST 
PUSH2 0x73 
PUSH1 0x4 
DUP1 
CALLDATASIZE 
SUB 
DUP2 
ADD 
SWAP1 
PUSH2 0x6E 
SWAP2 
SWAP1 
PUSH2 0x9D 
JUMP 
JUMPDEST 
PUSH2 0x7E 
JUMP 
JUMPDEST 
STOP 
JUMPDEST //jump2
PUSH1 0x0 //0x00 | 0x43
DUP1 //0 | 0 | 0x43
SLOAD //key => storage[key] 0x14（这就是从stroage中读取temp 0x14=20） | 0 | 0x43
SWAP1 // 0 | 0x14 | 0x43
POP //0x14 | 0x43
SWAP1 //0x43 | 0x14
JUMP //跳转0x43 jump3处
JUMPDEST
...
JUMPDEST  //jump6
PUSH1 0x0 //0 | 0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
DUP2 //0x14 | 0 | 0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
SWAP1 //0 | 0x14 | 0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
POP //0x14 | 0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
SWAP2 //0x9B | 0x14 | 0x14 | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
SWAP1 // 0x14 | 0x9B | 0x14 | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
POP //0x9B | 0x14 | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
JUMP//跳转到jump7
JUMPDEST //jump5
PUSH2 0x9B //0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
DUP2 //0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
PUSH2 0x88 //0x88 | 0x14 | 0x9B | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
JUMP //跳转到jump6
JUMPDEST //jump7
DUP3 //0x80 | 0x14 | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
MSTORE //在内存0x80-0x80+32位置存入0x14
POP //0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
POP //0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
JUMP //跳转到jump8
...
JUMPDEST //jump4
PUSH1 0x0 //0 | 0x80 | 0x14 | 0x50
PUSH1 0x20 //0x20 | 0 | 0x80 | 0x14 | 0x50
DUP3 //0x80 | 0x20 | 0 | 0x80 | 0x14 | 0x50
ADD //0xa0 | 0 | 0x80 | 0x14 | 0x50
SWAP1 //0 | 0xa0 | 0x80 | 0x14 | 0x50
POP //0xa0 | 0x80 | 0x14 | 0x50
PUSH2 0xB6 //0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
PUSH1 0x0 //0 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
DUP4 //0x80 | 0 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
ADD //0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
DUP5 //0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
PUSH2 0x92 //0x92 | 0x14 | 0x80 | 0xb6 | 0xa0 | 0x80 | 0x14 | 0x50
JUMP //跳转到jump5
JUMPDEST //jump8
SWAP3 //0x50 | 0x80 | 0x14 | 0xa0
SWAP2 //0x14 | 0x80 | 0x50 | 0xa0
POP //0x80 | 0x50 | 0xa0
POP //0x50 | 0xa0
JUMP //跳转到jump9
```