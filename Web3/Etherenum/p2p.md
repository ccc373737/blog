## P2P模型

- 集中式：即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括节点 IP 地址、端口、节点资源等。结构简单，但有性能瓶颈和单点故障
- 纯分布式：节点之间建立随机网络，形成一个随机拓扑结构。会有广播泛洪的问题。
- 混合式：混合了集中式和分布式结构，网络中存在多个超级节点组成分布式网络，而每个超级节点则有多个普通节点与它组成局部的集中式网络。
- 结构化：纯分布式网络就是一个随机网络，而结构化网络则将所有节点按照某种结构进行有序组织，比如形成一个环状网络或树状网络。普遍都是基于 DHT(Distributed Hash Table，分布式哈希表) 算法思想，具体实现有Kademlia算法等。

在P2P网络中，可以抽象出两种空间：资源空间和节点空间。资源空间就是所有节点保存的资源集合，节点空间就是所有节点的集合。对所有资源和节点分别进行编号，如把资源名称或内容用 Hash 函数变成一个数值（这也是 DHT 常用的一种方法），这样，每个资源就有对应的一个 ID，每个节点也有一个 ID，资源 ID 和节点 ID 之间建立起一种映射关系，比如，将资源 n 的所有索引信息存放到节点 n 上，那要搜索资源 n 时，只要找到节点 n 即可，从而就可以避免泛洪广播，能更快速而又准确地路由和定位数据。当然，在实际应用中，资源 ID 和节点 ID 之间是无法做到一一对应的，但因为 ID 都是数字，就存在大小关系或偏序关系等，基于这些关系就能建立两者的映射关系。这就是 DHT 的核心思想。DHT 算法在资源编号和节点编号上就是使用了分布式哈希表，使得资源空间和节点空间的编号有唯一性、均匀分布式等较好的性质，能够适合结构化分布式网络的要求。

## 以太坊P2P结构

以太坊P2P大致分为三层

1. 底层：table对象、node对象，它们分别定义了底层的路由表以及本地节点的数据结构、搜索和验证。
    - database.go         //封装node数据库相关操作
    - node.go             //节点数据结构
    - ntp.go              //同步时间
    - table.go            //路由表
    - udp.go              //网络相关操作
2. 中层：peer对象定义了远端节点、message对象开放发送接口、server对象则提供peer节点的检测、初始化、事件订阅、状态查询、启动和停止等功能。
    - dial.go          //封装一个任务生成处理结构以及三种任务结构中（此处命名不太精确
    - message.go       //定义一些数据的读写接口，以及对外的Send/SendItem函数
    - peer.go          //封装了Peer 包括消息读取
    - rlpx.go          //内部的握手协议
    - server.go        //初始化，维护Peer网络，还有一些对外的接口
3. 顶层：在eth/peer.go中对p2p/peer.go的peer再封装，包含了对该节点广播的更多区块链的信息，如交易、交易hash、区块以及区块头hash等。peer最终会被收集在peerset中使用。
    - eth/peer.go    // 封装了peer和peerset两个结构体以及一些广播数据的方法
    - eth/handler.go  // 封装了很多协议管理工具

## 节点发现

以太坊网络中，也会维护类似的一个节点列表 (NodeTable)，使用Kademlia算法形成网络。KAD 网络会维护一个路由表，用于快速定位目标节点。由于 KAD 网络基于 UDP 通信协议，所以以太坊节点的节点发现是基于 UDP 的，如果找到节点以后，数据交互又会切换到 TCP 协议上。

- **Ping**：用于探测一个节点是否在线
- **Pong**：用于响应 Ping 命令
- **FindNode**：用于查找与 Target 节点异或距离最近的其他节点
- **Neighbours**：用于响应 FindNode 命令，会返回一或多个节点

当新节点加入时，主要是先要构建自己的k-桶，需要进行如下步骤：

1. 新节点首先向任意一个节点发起查询请求（FIND_NODE），查询自己的ID。
2. 节点收到请求后，按照距离把新节点放到自己对应的K-桶中，然后按照协议找到K个与新节点最接近的节点返回。
3. 新节点收到返回的节点信息后，即可初始化自己的k-桶，并向这些节点发送查询请求，如此往复（递归），建立起自己的路由表。

当旧节点收到一个新节点信息的时候，要进行如下步骤：

1. 计算自己与新节点的距离，根据这个距离，选择对应的k-桶进行操作。
2. 如果新节点的ip已经在这个k-桶，则将这一项移动到k-桶的尾部。
3. 如果新节点的ip不在这个k-桶：
    - 如果k-桶记录小于k，则直接把发送者添加进去。
    - 如果k-桶记录大于等于k，则选择头部的节点进行PING操作，如果没有响应，则删除这个节点，添加新节点到尾部；如果有响应，就忽略新节点。

[节点启动](./p2p/节点启动.md)

## 节点交互

[Message](./p2p/Message.md)

整体过程

1. 以太坊网络分为三层：一是底层的k桶和储存节点的数据库模块；二是p2p网络服务的逻辑层，包括Server模块、message模块、dail模块、rplx模块和peer模块；最后一层是顶层eth中对逻辑层方法的包装（eth.peer）以及ProtocolManger（连接逻辑层和顶层的桥梁）。
2. p2p网络的启动从Node模块开始，Node.Start()函数开启了两个任务，一个是初始化Ethereum对象，同时初始化ProtocolManager，最后将Ethereum服务注册到node中；另一个是启动p2p.Server，新建并刷新K桶，开启UDP端口监听，同时监听TCP端口，处理从远端节点发来的message。
3. UDP用于K桶维护过程中的节点查找，而TCP则是用于实际实现peer的连接。
4. peer连接会发送到Server.run的循环中，调用newPeer生成新的peer，同时让对这个peer开启pingLoop和readLoop两个协程在两个节点之间读取和发送请求。

## 广播

[广播](./p2p/广播.md)